# what is a computer?

<table>
  <tr>
    <td width="50%">
      <img src="../images/computer.jpg" alt="computer image">
    </td>
    <td width="50%">
      i like computers.
    </td>
  </tr>
</table>

this is a very basic question and seems simple, but when you start thinking, you might get lost in lots of answers or no answer.
the truth is, there is no one answer to this question. the definition of a computer has changed a lot over time. 
computers were present even before the transistor, in theoretical and mechanical forms. as technology evolved, so did our understanding of what a computer is.

### historical evolution

in the early 19th century, the term "computer" referred to humans who could solve calculations by hand or with the help of simple mechanical devices. 

time passed and the definition evolved to include mechanical and electromechanical devices, such as the abacus, the antikythera mechanism, and later, devices like the babbage engine and hollerith's tabulating machines.

### the turing machine

it was the scientist alan turing, known as the father of the modern computer science, who described a machine that was named the turing machine. 

a turing machine is a simple, theoretical device invented by the mathematician alan turing in 1936 to help understand the limits of what can be computed.

imagine it like this:

1. **tape**: picture an infinitely long strip of paper (the tape) divided into small squares. each square can hold a symbol (like a 0 or 1).
2. **head**: there is a read/write head that moves along the tape, one square at a time. it can read the symbol in the current square, write a new symbol, and then move left or right.
3. **state**: the machine is always in one of a finite number of states. based on the current state and the symbol it reads, it will write a new symbol, move the head, and switch to a new state according to a set of rules (the program).

using these simple actions, a turing machine can perform any computation that can be algorithmically defined. this concept is fundamental because it helps define what it means for a problem to be computable and is the basis for modern computer science.
a problem is count computable if there exists a turing machine that can solve it. 
this definition helps differentiate between problems that can be solved by an algorithm (computable problems) and those that cannot (non-computable problems).

### modern computers

every computer that we use today, from the computer or cell phone you are reading this on to supercomputers, can come under the turing machine at their most simplistic level.

at its core, a computer is a machine that processes data by executing a set of instructions, known as algorithms, to perform calculations, manipulate information, and solve problems.


### how computer work ?

the whole premise of building a computer is to understand how it works. i might not be able to give an in-depth explanation now, but here's an overview:
as a programmer, i've tried to understand the workings of a computer in terms of how my program gets executed and generates output.

#lets write a c programe of adding two numbers that is a and b 

```markdown
this image illustrates the process of how high-level code gets converted to assembly language and then to binary machine code. let's break it down step by step:

1. high-level language (c code):
the example shows a simple c function:

```c
swap(int v[], int k) {
    int temp;
    temp = v[k];
    v[k] = v[k+1];
    v[k+1] = temp;
}
```

this is a function that swaps two adjacent elements in an array.

2. compiler:
the compiler takes this high-level code and translates it into assembly language. the compiler understands the semantics of the high-level language and generates equivalent assembly code.

3. assembly language:
the assembly code for the mips architecture is shown:

```assembly
swap:
    mult $2, $5, 4
    add  $2, $4, $2
    lw   $15, 0($2)
    lw   $16, 4($2)
    sw   $16, 0($2)
    sw   $15, 4($2)
    jr   $31
```

this is a lower-level representation of the same functionality, using specific cpu instructions and registers.

4. assembler:
the assembler takes the assembly code and converts it into binary machine code.

5. binary machine code:
the final step shows the binary representation that the computer's cpu can directly execute. each line represents a 32-bit instruction in binary format.

under the hood:

1. the compiler analyzes the high-level code, understanding its structure and meaning.
2. it then generates equivalent assembly code, choosing appropriate instructions and optimizing where possible.
3. the assembler converts symbolic assembly language into actual machine instructions (opcodes) and resolves memory addresses.
4. the resulting binary code is what gets loaded into memory and executed by the cpu.

this process of translation allows programmers to write in more human-readable and abstract high-level languages, while still leveraging the full capabilities of the underlying hardware. each step in the process adds a layer of abstraction, making programming more accessible and powerful, while still maintaining the ability to execute efficiently on the hardware.
```

